## 주요 위젯 알아보기 {#about-widget}

대시보드에 배치할 수 있는 위젯의 종류는 다음과 같습니다.

<Xclude product="redis">

### XOS 위젯

* ***[XOS] CPU***

  에이전트별 CPU 사용률을 실시간으로 확인할 수 있습니다.

* ***[XOS] Memory***

  에이전트별 메모리 사용률을 실시간으로 확인할 수 있습니다.

* ***[XOS] Disk Usage***

  에이전트별 디스크 사용률과 사용 가능 크기, 전체 크기 정보를 표시합니다. 
  
  * ![상세 아이콘](/img/ico-detail.svg) : <Cmdname sid="TTL07856" className="uitext" /> 팝업창이 나타납니다. 시간대별 디스크 사용량을 표시한 차트를 확인할 수 있습니다. 인스턴스별로 확인할 수 있으며, <UI>Size</UI>, <UI>Free</UI>, <UI>Used</UI> 버튼을 선택하면 전체 크기, 남은 크기, 사용 중인 크기를 확인할 수 있습니다. 

  * ![확대 아이콘](/img/ic-fullscreen.svg) : 위젯에 표시된 테이블을 더 넓은 화면으로 펼쳐볼 수 있습니다.

  :::tip

  데이터가 표시되지 않는다면 *xos.conf* 파일에 다음 설정을 추가하세요.

  ```ini title='xos.conf'
  # disk usage 0 이면 off, 단위: 초
  disk_usage_interval=60
  ```

  :::

</Xclude>

<InDoc product="postgresql,mysql">

### AWS RDS CloudWatch 위젯

* ***[RDS] CPUUtilization***

  RDS 데이터베이스의 인스턴스별 CPU 사용률을 실시간으로 확인할 수 있습니다.

* ***[RDS] FreeableMemory***

  RDS 데이터베이스의 인스턴스별 메모리 사용률을 실시간으로 확인할 수 있습니다.

* ***[RDS] FreeStorageSpace***

  RDS 데이터베이스의 사용 가능한 저장 공간의 양을 실시간으로 확인할 수 있습니다.

:::note

AWS CloudWatch 지표 조회를 위한 에이전트 설정 방법은 [다음 문서](agent-dbx-settings#using-aws-rds)를 참조하세요.

:::

</InDoc>

<InDoc product="oracle,oracle-pro">

### Oracle RAC 위젯

* ***[RAC] Load Balance***

  Oracle RAC(Real Application Clusters) 데이터베이스에서 실행 중인 인스턴스의 리소스를 실시간으로 모니터링할 수 있습니다. 사용자는 데이터베이스의 부하 및 성능 지표를 시각적으로 모니터링할 수 있습니다. CPU 성능 및 액티브 세션, 물리적 읽기 작업, 사용 가능한 메모리 수치를 확인할 수 있습니다.

* ***[RAC] Interconnect Bandwidth***

  Oracle RAC(Real Application Clusters)에서 사용되는 인터커넥트(Interconnect) 대역폭을 모니터링하는 위젯입니다. 데이터베이스 노드 간의 통신 대역폭을 실시간으로 표시하여 클러스터 내 데이터베이스, 인스턴스 간의 네트워크 트래픽 상태를 모니터링할 수 있습니다.

* ***[RAC] Main Waits***

  Global Lock 상태와 각 이벤트의 대기 횟수를 파악할 수 있습니다. 이 위젯은 데이터베이스의 특정 카테고리에서 수집한 지표를 통해 각 이벤트의 총 대기 횟수를 조회하고, 각 에이전트(인스턴스)의 가장 최근 데이터를 추출합니다. 이를 통해 특정 시간에 발생한 데이터베이스 대기 이벤트 상태를 신속하게 파악할 수 있습니다.

</InDoc>

<InDoc product="postgresql,mysql,oracle,oracle-pro,altibase,mongodb,mssql">

### Database 위젯

제공하는 위젯을 통해 데이터베이스 성능 분석의 주요 지표로, CPU, 메모리, 디스크 I/O 등 다양한 시스템 리소스의 상태를 확인할 수 있습니다.

</InDoc>

<InDoc product="postgresql,mysql,oracle,oracle-pro,altibase,cubrid,mssql">

* ***Active Sessions***

  시간에 따른 액티브 세션의 수치를 시계열 차트로 시각적으로 표시합니다. 데이터베이스에서 실행 중인 세션의 수를 시간별로 추적하여 그래프로 나타낸 위젯입니다. 세션의 사용 패턴 및 부하를 시각적으로 파악하는 데 유용합니다.

* ***Lock Wait Sessions***

  시간에 따른 락 대기 세션의 수치를 시계열 그래프로 시각적으로 표시합니다. 데이터베이스에서 락 대기 상태에 있는 세션의 수를 시간별로 추적하여 실시간 그래프로 표시한 위젯입니다.

* ***Long Active Session Count***

  데이터베이스에서 실행되는 활성 세션의 장기 실행에 관한 정보를 제공합니다. 세션의 실행 시간에 따라 그룹화되어 시간 단위로 집계된 정보를 차트로 표시합니다. 오랜 시간 실행되는 세션을 식별하여 데이터베이스의 성능 문제나 리소스 누수를 조기에 감지하거나, 세션 실행 시간에 따른 분류를 통해 어떤 세션이 장기간 활성 상태로 유지되고 있는지 시각적으로 파악할 수 있습니다.

  3초 미만은 <span class="normal">파란색</span>, 3초 이상 10초 미만은 <span class="snormal">녹색</span>, 10초 이상 15초 미만은 <span class='slow'>주황색</span>, 15초 이상은 <span class='vslow'>빨간색</span>으로 표시합니다.

* ***Long Waiting Session Count***

  데이터베이스에서 락을 보유하거나 대기하는 세션의 장기 대기 시간에 대한 정보를 제공합니다. 락 정보와 활성 세션 정보를 결합하여 대기 중인 세션의 장기 대기 시간을 추적할 수 있습니다. 오랜 시간 동안 락을 보유하거나 대기하는 세션을 모니터링합니다. 어떤 세션이 오랜 시간 동안 락을 보유하거나 대기하고 있는지 시각적으로 파악할 수 있습니다.

  5초 미만은 <span class="normal">파란색</span>, 5초 이상 10초 미만은 <span class="snormal">녹색</span>, 10초 이상 60초 미만은 <span class='slow'>주황색</span>, 60초 이상은 <span class='vslow'>빨간색</span>으로 표시합니다.

* ***SQL Elapse Map***

  실행 중인 쿼리의 경과 시간을 실시간 차트로 표시합니다. 차트의 특정 영역을 드래그하면 ***Query List*** 목록을 확인할 수 있습니다. ![위 방향 아이콘](/img/up-arrow.svg) 또는 ![아래 방향 아이콘](/img/down-arrow.svg) 버튼을 선택해 세로축의 범위를 확대 또는 축소할 수 있습니다.

  :::note

  쿼리의 실행 시간은 액티브 세션을 수집하여 계산합니다. 따라서 액티브 세션 수집 주기에 따라 오차 범위가 발생할 수 있습니다. 다음 그림을 참고하세요. 수집 주기 사이에 종료된 SQL 수행 시간은 계산되지 않습니다. 수집 주기가 짧을 수록 오차 범위는 줄어들 수 있지만 DB 부하를 고려해 일반적으로 5초로 셋팅했습니다. 장시간 수행되는 쿼리 모니터링에 유용합니다. ***SQL 통계*** 메뉴의 데이터도 동일합니다.

  ![](/img/db-sql-elapse-map-example.png)

  :::

</InDoc>

<InDoc product="oracle,oracle-pro">

* ***Wait Event***

  각 백엔드 프로세스가 현재 대기 중인 대기 이벤트 이름과 해당 이벤트의 발생 빈도를 실시간 그래프로 표시합니다. 주로 Application, Configuration, Administrative, Network 등과 관련된 항목의 대기 이벤트를 모니터링합니다. 각 대기 이벤트의 발생 빈도를 시각적으로 확인할 수 있으며, 그래프 위로 마우스를 가져가면 툴팁이 표시되어 각 대기 이벤트에 대한 자세한 정보를 제공합니다.

* ***Physical Reads***

  데이터베이스에서 발생하는 물리적인 읽기 작업(physical reads)을 모니터링하는 위젯입니다. 주로 데이터베이스가 디스크에서 데이터를 읽어오는 작업에 대한 통계를 제공하여 데이터베이스의 I/O 성능을 모니터링합니다.

* ***Excute Count***

  데이터베이스에서 실행된 쿼리 또는 프로시저의 실행 횟수를 모니터링하는 위젯입니다. 데이터베이스에 의해 실행된 쿼리나 프로시저의 실행 횟수를 실시간으로 추적하여 사용자에게 제공합니다.

* ***Session Logical Reads***

  데이터베이스 세션에서 수행된 논리적인 읽기 작업(logical reads)을 모니터링하는 위젯입니다. 데이터베이스 세션에서 수행된 논리적인 읽기 작업의 횟수를 실시간으로 추적하여 사용자에게 제공합니다.

</InDoc>

<InDoc product="mssql">

* ***Cache Hit Ratio*** (Buffer Manager.Buffer cache hit ratio)

  SQL Server가 데이터를 디스크에서 읽지 않고 메모리 버퍼풀에서 찾은 페이지의 비율입니다. 값이 높을수록 성능이 우수함을 의미하며, 낮다면 메모리 용량 부족이나 버퍼 풀 관리 문제를 의심해야 합니다. 일반적으로 이 값은 90% 이상을 유지할 것을 권장합니다.

* ***Page Life Expectancy*** (Buffer Manager.Page life expectancy)

  데이터 페이지가 버퍼풀에 머무르는 평균 시간을 초 단위로 표시합니다. 버퍼풀에 오래 머물수록 메모리에서 데이터를 읽으므로 디스크 I/O가 줄어들고 성능이 향상됩니다. 이 값이 낮다면 메모리가 부족하거나 작업 부하가 증가한 상태이며, 권장값은 최소 300초(5분) 이상입니다. 지속적으로 낮을 경우 메모리 추가를 고려해야 합니다.

* ***Full Scans/sec***

  초당 수행된 테이블 또는 인덱스 전체 스캔 횟수입니다. 전체 스캔은 필요한 데이터만 읽는 인덱스 스캔에 비해 비효율적이므로, 이 값이 높으면 쿼리 최적화 또는 적절한 인덱스 설계가 필요할 수 있습니다. 빈번한 전체 스캔은 CPU 사용률 증가 및 성능 저하를 유발할 수 있습니다.

* ***Page Lookups/sec*** (Buffer Manager.Page lookups/sec)

  버퍼풀에서 페이지를 찾기 위한 요청 수입니다. 이 값이 높으면 더 많은 데이터를 처리 중임을 의미하며, 대규모 쿼리 실행이나 테이블 스캔 발생 가능성을 보여줍니다. 값이 비정상적으로 높으면 인덱스 누락, 잘못된 쿼리 설계 등을 확인해야 하며 CPU 사용량 증가와 연결될 수 있습니다.

* ***Page Reads/sec*** (Buffer Manager.Page reads/sec)

  모든 데이터베이스에서 물리적으로 디스크에서 읽은 초당 페이지 수입니다. 이 값이 높으면 디스크 I/O가 많아 성능 저하를 유발할 수 있습니다. 개선을 위해 데이터 캐시 크기를 늘리거나, 쿼리 튜닝 및 인덱스 최적화를 검토하세요. 디스크에서의 실제 읽기 작업은 큰 비용이 발생할 수 있으므로 주의가 필요합니다.

* ***Page Writes/sec*** (Buffer Manager.Page writes/sec)

  물리적으로 디스크에 기록된 초당 데이터베이스 페이지 수입니다. 쓰기 작업이 빈번할 경우 트랜잭션 부하가 많거나 대량 데이터 입력 작업이 원인일 수 있습니다. 데이터 쓰기 작업이 많으면 I/O 병목현상이 발생할 가능성이 있으므로, 트랜잭션 분할, 디스크 성능 향상, 로그 파일 크기 조정 등을 검토하세요.

</InDoc>

<InDoc product="altibase">

* ***Logical Reads*** (data page gets)

  시스템 또는 세션에서 래치를 사용하여 데이터 페이지에 접근한 횟수입니다. 버퍼의 Hit Ratio는 `(get pages + fix pages - read pages) / (get pages + fix pages)`로 계산합니다.

* ***Physical Reads*** (data page read)

  시스템 또는 세션에서 페이지를 읽은 횟수로, 버퍼에 적재되지 않은 페이지를 디스크에서 읽어오는 물리적인 읽기 횟수입니다. 물리적 읽기 횟수가 많을수록 시스템의 쿼리 처리 속도가 저하될 수 있습니다.

* ***Memory Table Access*** (memory table access count)

  시스템 또는 세션에서 메모리 테이블에 접근한 횟수입니다.

* ***Disk Table Full Scan*** (disk table cursor full scan count)

  시스템 또는 세션에서 디스크 테이블에 대한 풀 스캔 커서를 연 횟수입니다.

* ***Commits*** (session commit)

  시스템 또는 세션에서 발생한 커밋(Commit) 횟수입니다.

* ***Undo Reads*** (undo page gets)

  시스템 또는 세션에서 래치를 사용하여 UNDO 페이지에 접근한 횟수입니다.

* ***Execute Count*** (execute success count)

  시스템 또는 세션에서 쿼리가 성공적으로 실행된 횟수입니다. 트랜잭션 처리량을 평가할 때 `execute success count + prepare success count + prepare failure count`로 계산할 수 있습니다.

* ***Prepare Count*** (prepare success count)

  시스템 또는 세션에서 Prepare 단계가 성공한 횟수입니다. 이 단계는 쿼리 문법 오류 확인 및 실행 계획 수립을 포함하며, 전체 쿼리 처리 시간의 60-70%를 차지할 수 있습니다. 이 값이 지나치게 높다면 반복적인 Prepare 작업을 줄이도록 쿼리 최적화가 필요합니다.

</InDoc>

<InDoc product="cubrid">

* ***Logical Reads*** (num_data_page_fetches)

  메모리에서 가져온 데이터 페이지의 수입니다. 데이터베이스가 디스크에서 데이터를 읽기 전에 메모리에 이미 있는 데이터를 우선적으로 조회하는 경우가 많습니다. 이 지표는 캐시나 버퍼를 사용하여 데이터베이스의 효율성을 평가하는 데 중요한 역할을 합니다. 이 값이 높을수록 메모리에서 데이터를 많이 가져온다는 의미하며, 디스크 I/O 부담을 줄이는 데 기여합니다.

* ***Pysical Reads*** (num_data_page_ioreads)

  디스크에서 실제로 읽은 데이터 페이지의 수입니다. 이 값이 높을수록 메모리 대신 디스크에서 데이터를 많이 읽고 있음을 의미합니다. 이는 시스템 성능에 부정적인 영향을 미칠 수 있습니다. 이 값이 높을수록 데이터베이스의 히트율이 낮고 I/O 성능이 저하될 수 있으므로, 이 값을 최적화하는 것이 중요합니다.

* ***Executions*** (executions)

  DML(데이터 조작 언어) 명령어의 실행 횟수입니다. `SELECT`, `INSERT`, `UPDATE`, `DELETE`와 같은 쿼리 실행이 포함됩니다. 이 지표는 데이터베이스에서 수행되는 전체 작업량을 파악하는 데 도움을 주며, 데이터베이스의 처리 성능을 모니터링할 수 있는 핵심 요소입니다.

  :::note

  산출 방식: `num_query_selects` + `num_query_inserts` + `num_query_updates` + `num_query_deletes`

  :::

* ***Full Scans*** (num_query_sscans)

  순차 스캔(Full scan) 횟수입니다. 풀 스캔(Full scan)은 인덱스를 사용하지 않고 테이블 전체를 스캔하여 데이터를 조회하는 방식으로, 성능이 떨어지는 작업입니다. 풀 스캔 횟수가 많을수록 쿼리 성능에 영향을 미칠 수 있으며 인덱스 최적화가 필요함을 의미합니다.

* ***Buffer Hit Ratio(%)*** (data_page_buffer_hit_ratio)

  데이터 페이지 버퍼의 히트율을 백분율로 표시한 지표입니다. 히트율이 높을수록 데이터가 메모리 버퍼에서 빠르게 조회되고 있다는 의미이며, 이는 시스템 성능을 높이는 데 기여합니다. 반대로 히트율이 낮으면 물리적 I/O가 많아져 성능 저하로 이어질 수 있습니다.

  :::note

  산출 방식: ((`Num_data_page_fetches` - `Num_data_page_ioreads`) / `Num_data_page_fetches`) * 100

  :::

* ***Disk Sorts*** (num_sort_io_pages)

  디스크에서 정렬 작업을 수행하면서 가져온 페이지의 개수입니다. 디스크 정렬은 메모리 내에서 처리되지 못한 정렬 작업을 의미하며, 이 값이 클수록 성능이 저하될 수 있습니다. 메모리에서 처리가 가능한 정렬을 늘리기 위해 메모리 크기나 정렬 전략을 조정할 필요가 있습니다.

* ***CAS Memory size*** (psize)

  `cub_cas`(CUBRID Application Server) 프로세스에서 사용 중인 메모리 크기입니다. 이 값은 CUBRID의 브로커(CAS) 프로세스가 메모리에서 차지하는 양을 의미하며, 여러 개의 브로커가 실행 중인 경우 그 합산 값을 표시합니다. 메모리 사용량이 비정상적으로 높으면 메모리 누수가 발생했거나 시스템에 부하가 걸리고 있음을 의미할 수 있습니다.

* ***CAS count*** (broker_count)

  현재 실행 중인 `cub_cas`(CUBRID Application Server) 프로세스의 개수입니다. 이 값은 브로커 프로세스의 개수로, 브로커가 많을수록 여러 요청을 병렬로 처리할 수 있습니다. 그러나 브로커가 많을수록 리소스 소비도 증가하므로 적절한 설정이 필요합니다.

* ***Replication Delay*** (time_ha_replication_delay)

  CUBRID의 High Availability(HA) 환경에서 복제 지연 시간을 초 단위로 나타냅니다. 이 지표는 주(Primary) 서버에서 복제본(Replica) 서버로 데이터가 동기화되는 데 걸리는 시간입니다. 이 값이 클수록 데이터 동기화 지연이 발생하고 있음을 의미합니다. 복제 지연이 지속되면 시스템의 가용성과 데이터 일관성에 영향을 미칠 수 있습니다.

</InDoc>

<InDoc product='postgresql'>

* ***DML Tuples***

  DML(Data Manipulation Language) 문법(statement)이 수행된 횟수를 실시간 차트로 표시합니다.

* ***Slow Query***

  시간대별 슬로우 쿼리를 실시간 차트로 표시합니다. 차트의 특정 영역을 드래그하면 ***Slow Query List*** 목록을 확인할 수 있습니다. ![위 방향 아이콘](/img/up-arrow.svg) 또는 ![아래 방향 아이콘](/img/down-arrow.svg) 버튼을 선택해 세로축의 범위를 확대 또는 축소할 수 있습니다.

* ***Logical I/O***

  `blks_hit` 지표로, 디스크 블록이 이미 버퍼 캐시에서 발견되어 읽기가 필요하지 않은 총 횟수입니다.

* ***Physical I/O***

  물리적인 disk에서 데이터를 읽은 횟수입니다.

* ***Uptime***

  에이전트(인스턴스)가 기동한 지 얼마나 시간이 지났는지 확인할 수 있습니다. 시간은 `{dd}d {hh:mm:ss}` 형식으로 표시합니다.

* ***Commits***

  시스템 또는 세션에서 발생한 커밋(Commit) 횟수입니다.

* ***Replication Delay***

  Replication 구조일 경우 replication DB에 반영되는 지연 시간을 실시간 차트로 표시합니다.

* ***Wait Event***

  각 백엔드 프로세스가 현재 대기 중인 대기 이벤트 이름과 해당 이벤트의 발생 빈도를 실시간 그래프로 표시합니다. 주로 Application, Configuration, Administrative, Network 등과 관련된 항목의 대기 이벤트를 모니터링합니다. 각 대기 이벤트의 발생 빈도를 시각적으로 확인할 수 있으며, 그래프 위로 마우스를 가져가면 툴팁이 표시되어 각 대기 이벤트에 대한 자세한 정보를 제공합니다.

* ***Vacuum Sessions***

  현재 진행 중인 vacuum 프로세스 수를 확인할 수 있습니다. 위젯 오른쪽 상단에 ![상세 아이콘](/img/ico-detail.svg) 버튼을 선택하면 <Cmdname sid="TTL08277" className="uitext" /> 창이 나타납니다. <Cmdname sid="TTL08277" className="uitext" />에서는 진행되었던 vacuum 프로세스의 상세 정보를 확인할 수 있습니다.

</InDoc>

<InDoc product="mysql">

* ***Questions***

  MySQL 서버에서 실행한 명령문 수입니다. Stored program 내에서 실행된 명령문을 계산하지 않는다는 점 에서 Queries와 다릅니다.

* ***Slow Query***

  시간대별 슬로우 쿼리를 실시간 차트로 표시합니다. 차트의 특정 영역을 드래그하면 ***Slow Query List*** 목록을 확인할 수 있습니다. ![위 방향 아이콘](/img/up-arrow.svg) 또는 ![아래 방향 아이콘](/img/down-arrow.svg) 버튼을 선택해 세로축의 범위를 확대 또는 축소할 수 있습니다.

* ***Logical I/O***

  물리적 읽기 포함한 논리적 읽기 요청 횟수입니다. `Inodb buffer pool hit` 백분율 계산을 다음과 같이 할 수 있으며, 90% 이상을 권장합니다. 만약 Hit Ratio가 낮다면 `Innodb_buffer_pool_size` 증설을 검토하세요.

  > `Buffer Hit Ratio` = (1 - (`Innodb_buffer_pool_reads`/`Innodb_buffer_pool_read_requests`)) * 100

* ***Physical I/O***

  물리적인 disk에서 데이터를 읽은 횟수입니다.

* ***Uptime***

  에이전트(인스턴스)가 기동한 지 얼마나 시간이 지났는지 확인할 수 있습니다. 시간은 `{dd}d {hh:mm:ss}` 형식으로 표시합니다.

* ***Commits***

  시스템 또는 세션에서 발생한 커밋(Commit) 횟수입니다.

* ***Replication Delay***

  Replication 구조일 경우 replication DB에 반영되는 지연 시간입니다.

* ***Select Full Join***

  하나 이상의 테이블을 조인(`JOIN`)할 때 인덱스를 사용하지 않고 드리븐(Driven) 테이블에 대해 풀 스캔(Full Scan)이 수행된 횟수입니다.

* ***Tmp Tables***

  인스턴스별 명령문을 실행하는 동안 서버에 의해 생성된 내부 임시 테이블의 수입니다.

</InDoc>

<InDoc product="redis,mongodb">

* ***DB Status***

  프로젝트에 포함된 에이전트(인스턴스)의 상태를 확인할 수 있습니다. 개별 에이전트를 육각형 모양으로 표시하며, 마우스를 오버하면 현재 상태와 IP 주소를 확인할 수 있습니다.

  ![DB Status](/img/db-dashboard-status-widget.png)

  에이전트의 상태는 다음과 같이 구분할 수 있습니다.

  * <span class='normal'>정상</span>: 정상 상태의 에이전트 수입니다.

  * <span class='mstop'>비활성화된 에이전트</span>: 연결이 해제된 에이전트의 수입니다.

</InDoc>

<InDoc product="redis">

* ***Clusters***

  Master 인스턴스와 Slave 인스턴스의 현황을 확인할 수 있습니다.

  :::note

  ***Clusters*** 위젯을 이용하려면 DBX 에이전트(*whatap.conf*)의 다음 옵션을 설정해야 합니다. 자세한 내용은 [다음 문서](agent-dbx-settings#cluster-set)를 참조하세요.

  ```ini title="whatap.conf"
  cluster_name={cluster_name}
  ```

  :::

* ***Instantaneous Ops Per Sec***

  ![Instantaneous Ops Per Sec](/img/db-dashboard-instaneous-widget.png)

  서버가 처리하는 초당 명령 수(`instantaneous_ops_per_sec`)를 파이 차트를 이용해 표시합니다. 여러 인스턴스 간의 성능을 비교하고 모니터링하는 지표로 사용할 수 있습니다.

  :::tip

  `instantaneous_ops_per_sec` 지표는 서버가 처리하는 초당 명령 수입니다. 인스턴스가 현재 처리 중인 작업 부하를 추적하고 모니터링하는 데 유용합니다. 초당 명령 수는 서버가 받아들이고 처리하는 명령의 양을 나타내며, 서버의 작업 부하를 파악하고 성능 문제를 식별하는 데 도움이 됩니다.

  :::

* ***Key Status***

  서버의 키(Key) 상태를 모니터링합니다. 데이터베이스의 상태를 이해하고 성능을 최적화하는 데 필요합니다.

  * ***Evicted Keys***: 캐시되었거나 저장된 Key 중에 만료됐거나 메모리 정책에 따라 삭제된 키의 수를 표시합니다. ***Evicted Keys*** 지표가 증가하면 메모리 부족이나 캐시 정책에 문제가 있을 수 있습니다.

  * ***Expired Keys***: 만료된 Key 수를 표시합니다. Redis는 Key에 만료 시간을 설정할 수 있으며, 만료된 키는 자동으로 삭제됩니다. ***Expired Keys*** 지표가 증가하면 데이터베이스에서 만료 정책을 검토하거나 사용자 동작을 점검할 필요가 있습니다.

  * ***Keyspace Hits***: 데이터베이스에서 Key를 검색하고 가져오는 요청 중 캐시나 메모리에서 키를 찾는 성공 요청 수를 표시합니다. 캐시 효율성을 평가하고 Key에 대한 액세스 패턴을 이해하는 데 도움이 되는 지표입니다.

  * ***Keyspace Misses***: 데이터베이스에서 Key를 검색하고 가져오는 요청 중 캐시나 메모리에서 키를 찾지 못한 실패 요청 수를 표시합니다. 캐시 효율성을 평가하고 성능 향상을 위한 조치를 취하는 데 필요한 지표입니다.

  :::note

  Redis 데이터베이스에서 키(Key)는 문자열, 해시, 리스트, 셋, 정렬 집합 등의 다양한 데이터 유형을 포함합니다.

  :::

* ***Connected Clients*** (`connected_clients`)

  현재 접속 중인 클라이언트의 수입니다. 서버에 대한 동시 연결 수를 파악할 수 있습니다. 서버에 대한 클라이언트 연결 수가 급격하게 증가한다면 예상치 못한 트래픽 증가나 다른 문제를 나타낼 수 있으므로, 이러한 상황을 신속하게 인식하고 대응할 필요가 있습니다.

* ***Used Memory*** (`used_memory`)

  데이터를 저장하기 위해 요청한 메모리 양(byte)입니다. 운영체제에서 할당한 메모리양과 차이가 있을 수 있습니다. `used_memory` 지표가 너무 높다면 메모리 관리 정책을 검토하고, 데이터 세트를 최적화하여 메모리 사용량을 줄이는 것이 필요할 수 있습니다.

* ***Total Commands*** (`total_commands_processed`)

  서버를 시작한 이후 처리한 총 명령 수를 표시하는 위젯입니다. 서버가 수행한 모든 명령의 누적 횟수를 나타내며, 서비스를 제공하는 동안 처리한 모든 클라이언트의 요청 수를 포함합니다. `total_commands_processed` 지표는 서버의 활동 수준을 파악하고 성능을 평가하는데 유용한 지표입니다. 이 지표는 시간이 지남에 따라 증가하며, 값의 변화를 추적해 서버의 활동 수준을 계속 모니터링할 필요가 있습니다.

* ***Used CPU*** (`used_cpu`)

  Redis는 인스턴스별로 하나의 CPU를 사용하며 할당된 CPU 사용량을 표시합니다. `used_cpu` 지표는 서버가 CPU 자원을 어떻게 사용하는지를 파악할 수 있습니다. 이 지표가 예상치 못한 수준으로 증가하면 성능 문제로 인식하고 성능을 최적화하는 것이 필요합니다.

* ***Commands(/S)*** (`instantaneous_ops_per_sec`)

  서버가 처리하는 초당 명령 수(`instantaneous_ops_per_sec`)를 시간의 경과에 따른 각 인스턴스의 지푯값을 시계열 차트를 통해 표시합니다. 시간 경과에 따른 추이를 모니터링하고 성능 트렌드 및 이슈를 식별하는데 유용한 위젯입니다.

  :::tip

  `instantaneous_ops_per_sec` 지표는 서버가 처리하는 초당 명령 수입니다. 인스턴스가 현재 처리 중인 작업 부하를 추적하고 모니터링하는 데 유용합니다. 초당 명령 수는 서버가 받아들이고 처리하는 명령의 양을 나타내며, 서버의 작업 부하를 파악하고 성능 문제를 식별하는 데 도움이 됩니다.

  :::

* ***Total Net Input Bytes***

  서버가 수신한 총 네트워크 입력 양(bytes)을 나타내는 위젯입니다. 클라이언트로부터 받은 모든 네트워크 트래픽의 총량을 측정합니다. 이 위젯을 통해 클라이언트가 서버와 통신 중에 소비한 네트워크 대역폭을 파악하는데 도움이 됩니다. 클라이언트의 활동 수준을 추적하고 네트워크 부하를 관리하는데 유용할 수 있습니다.

* ***Blocked Clients*** (`blocked_clients`)

  서버에서 현재 블록 상태에 있는 클라이언트 수를 표시합니다. 블록된 클라이언트는 서버에서 특정 작업을 대기하고 있는 상태로, 대기 중인 작업이 완료될 때까지 클라이언트가 차단됩니다. 얼마나 많은 수의 클라이언트가 블록 상태인지 모니터링할 수 있습니다. 이 지표를 통해 서버의 현재 부하 상태를 쉽게 파악할 수 있습니다.

* ***Keys Total*** (`keys_total`)

  Redis 데이터베이스에 저장된 총 키(Key)의 수입니다. Key는 문자열, 해시, 리스트, 셋, 정렬 집합 등의 다양한 데이터 유형을 포함합니다. 데이터베이스에 저장된 전체 데이터의 양을 추적해 데이터베이스의 크기를 이해하고 데이터 성장 추이를 파악할 수 있습니다. 이 지표가 급격하게 증가한다면 추가 메모리를 할당하거나 데이터 정리 정책을 검토할 필요가 있습니다.

* ***Evicted Keys*** (`evicted_keys`)

  데이터베이스의 maxmemory 제한에 의해 제거된 키(Key)의 수입니다. 제거 정책은 구성 파일의 `maxmemory-policy` 설정에 따릅니다. 일반적으로 Key와 관련한 데이터의 유효 기간이 만료되었거나, 메모리 부족 등의 이유로 키를 삭제하면 `evicted_keys` 지표는 증가합니다. `evicted_keys` 지표 모니터링을 통해서 Key가 얼마나 자주 삭제되는지 추적하고 메모리 사용량과 성능을 파악할 수 있습니다.

* ***Keyspace Hits*** (`keyspace_hits`)

  Key 조회 요청 중 성공한 수입니다. `get key` 값이 있으면 1이 증가합니다. Hit Rate는 (`keyspace_hits` / (`keyspace_hits` + `keyspace_misses`) * 100 )으로 계산할 수 있습니다. `keyspace_hits` 지표는 데이터베이스 서버의 캐시 효율성을 평가하고 성능을 개션하는데 중요한 지표 중 하나입니다.

* ***Rdb Changes Since Last Save***

  데이터베이스에서 마지막 `SAVE` 명령 이후 변경된 데이터의 양을 나타내는 위젯입니다. 변경된 데이터의 양을 추적해 데이터의 변화 정도를 파악할 수 있습니다. 변경된 데이터의 양이 많다면 백업 주기를 조정하거나 데이터 손실 가능성을 줄이는 데터 백업 정책을 검토하세요.

* ***Total Net Output Bytes***

  데이터베이스 서버가 클라이언트에게 전송한 모든 네트워크 트래픽의 양을 표시한 위젯입니다. 서버가 클라이언트에 데이터를 전송하는 활동을 추적할 수 있습니다. 이를 통해 서버의 응답 속도 및 클라이언트 요청에 대한 처리 성능을 평가할 수 있습니다.

</InDoc>

<InDoc product="mongodb">

* ***Read requests***

  초당 읽기 요청 수를 측정한 위젯입니다. 읽기 요청은 데이터베이스에서 데이터를 조회하거나 검색하는 쿼리, 집계 작업, 인덱스 스캔 등과 관련한 작업입니다. 데이터베이스의 사용 패턴의 변화를 감지하는데 유용합니다.

  > 산출 방식: `query$opcounters` + `getmore$opcounters`

* ***Write requests***

  초당 쓰기 요청 수를 측정한 위젯입니다. 쓰기 요청은 데이터베이스에 새로운 데이터를 추가하거나 업데이트, 삭제와 관련한 작업입니다. 데이터베이스의 사용 패턴의 변화를 감지하는데 유용합니다.

  > 산출 방식: `insert$opcounters` + `update$opcounters` + `delete$opcounters`

* ***Read Latency*** (`latency$reads$opLatencies`)

  읽기 작업의 지연 시간(microsecond)을 측정한 위젯으로, 클라이언트가 읽기 작업을 요청하고 데이터베이스에서 해당 작업을 수행하는 데 걸린 시간입니다. 읽기 작업의 지연 시간이 긴 경우 인덱스를 최적화하거나 쿼리를 개선해 성능을 향상시키는 방법을 검토하세요.

* ***Write Latency*** (`latency$writes$opLatencies`)

  쓰기 작업의 지연 시간(microsecond)을 측정한 위젯으로, 클라이언트가 쓰기 작업을 요청하고 데이터베이스에서 해당 작업을 수행하는 데 걸린 시간입니다. 쓰기 작업의 지연 시간이 긴 경우 인덱스를 최적화하거나 쓰기 작업을 배치 처리해 성능을 향상시키는 방법을 검토하세요.

* ***Page Faults*** (`page_faults$extra_info`)

  페이지 폴트(page faults) 현상이 발생한 횟수를 측정한 위젯입니다. 페이지 폴트는 메모리 관리에서 발생하는 현상으로, 프로세스가 요청한 메모리 페이지가 물리적인 메모리에 없어서 디스크로부터 해당 페이지를 읽어와야 할 때 발생합니다. 이때 디스크 I/O가 발생해 작업이 지연될 수 있습니다. 일반적으로 시스템의 메모리 부족 상태를 의미합니다.

  데이터베이스의 읽기 및 쓰기 작업이 디스크 I/O에 의존하는지를 확인하고 메모리 부족 상태가 성능 문제의 원인이 되는지 파악할 수 있습니다.

  :::note

  Page faults에 대한 자세한 내용은 [다음 링크](https://www.mongodb.com/docs/v4.0/administration/analyzing-mongodb-performance/#page-faults)를 참조하세요.

  :::

* ***Active Connections*** (`active$connections`)

  현재 작업 중인 클라이언트의 연결 수를 측정한 위젯입니다. 데이터베이스 서버에서 동시에 처리할 수 있는 클라이언트의 연결 수를 모니터링할 수 있습니다. 높은 연결 수는 서버 용량을 증설할 필요가 있음을 의미합니다. 반대의 경우 문제가 발생했을 가능성이 있으므로 시스템 상태를 신속히 파악해 보는 것이 좋습니다.

* ***Read Clients*** (`readers$activeClients$globalLock`)

  MongoDB의 전역 잠금(global lock)에서 현재 읽기 작업을 수행 중인 클라이언트의 수를 측정한 위젯입니다. 데이터베이스 서버가 읽기 작업을 위해 얼마나 많은 수의 클라이언트를 처리하는지 파악할 수 있습니다. 데이터베이스의 성능을 모니터링하고 응답 시간을 추적하는데 유용한 지표입니다. 과도한 읽기 작업이 발생할 경우 성능 저하의 원인이 될 수 있습니다.

* ***Write Clients*** (`writers$activeClients$globalLock`)

  현재 MongoDB의 전역 잠금(global lock)에서 쓰기 작업을 수행 중인 클라이언트의 수를 측정한 위젯입니다. 데이터베이스 서버가 쓰기 작업을 위해 얼마나 많은 수의 클라이언트를 처리하는지 파악할 수 있습니다. 데이터베이스의 성능을 모니터링하고 응답 시간을 추적하는데 유용한 지표입니다. 과도한 쓰기 작업이 발생할 경우 성능 저하의 원인이 될 수 있습니다.

* ***Queued Read Requests*** (`readers$currentQueue$globalLock`)

  현재 시스템에서 대기 중인 읽기 작업을 처리하기 위해 전역 잠금(global lock)을 대기 중인 클라이언트의 수를 측정한 위젯입니다. 데이터베이스의 성능 및 확장성을 평가할 수 있는 정보를 제공합니다. 대기 중인 읽기 요청 작업이 많을 수록 클라이언트의 요청에 대한 응답 시간이 늘어날 수 있으며, 처리량이 한계에 도달할 수 있습니다.

  대기 중인 읽기 작업이 급격하게 증가할 경우 서버의 리소스 증설을 검토하거나, 대기 중인 읽기 작업의 원인을 분석하고 쿼리 최적화 및 인덱스 튜닝 등의 조치를 통해 병목 현상을 해결할 수 있습니다.

* ***Queued Write Requests*** (`writers$currentQueue$globalLock`)

  현재 시스템에서 대기 중인 쓰기 작업을 처리하기 위해 전역 잠금(global lock)을 대기 중인 클라이언트의 수를 측정한 위젯입니다. 데이터베이스의 성능을 평가하고 최적화하기 위한 필수 지표입니다. 대기 중인 쓰기 작업이 늘어나면 시스템 성능이 저하되거나 응답 시간이 증가할 수 있습니다.

  리소스 증설을 검토하거나 어떤 작업이 병목 현상을 유발하는지 파악해볼 필요가 있습니다.

* ***Resident Memory*** (`resident$mem`)

  현재 시스템에서 프로세스가 사용하는 메모리 사이즈(MB)입니다. 얼마나 많은 메모리를 사용하는지 파악할 수 있습니다. 메모리 사용량 추적을 통해 메모리 사용량을 최적화하여 성능을 향상시키고, 메모리 리소스를 효율적으로 활용하는데 중요한 지표가 됩니다. 또한 더 많은 메모리가 필요한지, 샤드를 추가해야 하는지를 결정하는데 도움이 됩니다.

* ***Virtual Memory*** (`virtual$mem`)

  현재 시스템에서 프로세스가 사용하는 가상 메모리 사이즈(MB)입니다. 현재 실행 중인 환경에서 얼마나 많은 메모리 리소스를 요구하는지를 파악할 수 있습니다. 가상 메모리의 사이즈를 파악하면 더 많은 물리 메모리가 필요할지, 가상 메모리 사용량을 줄이기 위한 조치를 결정하는데 도움이 됩니다.

* ***Network Out*** (`bytesOut$network`)

  클라이언트나 기타 인스턴스의 연결을 통해 서버가 보낸 총 바이트 수입니다. 데이터베이스 서버가 외부로부터 요청을 받고 응답을 반환할 때 전송한 데이터의 총량을 의미합니다. 데이터베이스 서버에서 발생하는 네트워크 트래픽을 파악할 수 있으며, 이를 통해 네크워크 대역폭이나 서버 리소스 사용에 대한 최적화를 진행할 수 있습니다. 또한 높은 네트워크 트래픽은 응답 시간의 증가와 같은 성능 문제와 연관되어 있습니다.

* ***Network In*** (`bytesIn$network`)

  클라이언트나 기타 인스턴스의 연결을 통해 서버가 수신한 총 바이트 수입니다. 데이터베이스 서버가 외부로부터 수신한 요청 및 데이터의 총량을 의미하며, 클라이언트가 데이터베이스 서버로부터 요청을 보내고 응답을 받을 때 발생하는 데이터 전송량을 포함합니다. 특정 애플리케이션 또는 작업에서 데이터베이스와 어떻게 통신을 사용하는지 파악할 수 있습니다. 또한 네트워크 트래픽의 추이를 파악하여 시스템의 용량을 게획하고 확정성을 평가할 수 있습니다.

:::note

전역 잠금(globl lock)은 MongoDB에서 데이터의 일관성을 유지하기 위해 사용되는 메커니즘입니다. 읽기와 쓰기 작업 모두에 적용되며, 작업을 수행하려는 클라이언트는 전역 잠금을 획득해야 합니다.

:::

</InDoc>